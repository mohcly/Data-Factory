#!/usr/bin/env python3
"""
Real-Time Cryptocurrency Orderbook Monitor
==========================================

Monitors live orderbook data from Binance Futures for multiple cryptocurrencies.
Captures bid/ask spreads, market depth, and orderbook dynamics in real-time.

Features:
- Real-time orderbook snapshots for 24+ cryptocurrencies
- WebSocket streaming from Binance Futures
- Automatic data persistence and compression
- Live statistics dashboard
- Colored terminal output
- Configurable update frequencies

Author: MVP Crypto Data Factory
Created: 2025-10-18
"""

import asyncio
import websockets
import json
import pandas as pd
from datetime import datetime, timedelta
import os
import sys
import signal
import logging
from pathlib import Path
from typing import Dict, List, Set, Optional
import argparse
import gzip
import threading
import time

# ANSI color codes for terminal output
class Colors:
    # Basic colors
    BLACK = '\033[30m'
    RED = '\033[31m'
    GREEN = '\033[32m'
    YELLOW = '\033[33m'
    BLUE = '\033[34m'
    MAGENTA = '\033[35m'
    CYAN = '\033[36m'
    WHITE = '\033[37m'

    # Bright colors
    BRIGHT_RED = '\033[91m'
    BRIGHT_GREEN = '\033[92m'
    BRIGHT_YELLOW = '\033[93m'
    BRIGHT_BLUE = '\033[94m'
    BRIGHT_MAGENTA = '\033[95m'
    BRIGHT_CYAN = '\033[96m'
    BRIGHT_WHITE = '\033[97m'

    # Background colors
    BG_RED = '\033[41m'
    BG_GREEN = '\033[42m'
    BG_YELLOW = '\033[43m'
    BG_BLUE = '\033[44m'
    BG_MAGENTA = '\033[45m'
    BG_CYAN = '\033[46m'
    BG_WHITE = '\033[47m'

    # Text styles
    BOLD = '\033[1m'
    DIM = '\033[2m'
    UNDERLINE = '\033[4m'
    BLINK = '\033[5m'
    REVERSE = '\033[7m'

    # Reset
    RESET = '\033[0m'

    @staticmethod
    def colorize(text: str, color: str, style: str = "") -> str:
        """Colorize text with specified color and style."""
        return f"{style}{color}{text}{Colors.RESET}"

    @staticmethod
    def success(text: str) -> str:
        """Green text for success messages."""
        return Colors.colorize(text, Colors.BRIGHT_GREEN, Colors.BOLD)

    @staticmethod
    def error(text: str) -> str:
        """Red text for error messages."""
        return Colors.colorize(text, Colors.BRIGHT_RED, Colors.BOLD)

    @staticmethod
    def warning(text: str) -> str:
        """Yellow text for warning messages."""
        return Colors.colorize(text, Colors.BRIGHT_YELLOW)

    @staticmethod
    def info(text: str) -> str:
        """Blue text for info messages."""
        return Colors.colorize(text, Colors.BRIGHT_BLUE)

    @staticmethod
    def data(text: str) -> str:
        """Cyan text for data values."""
        return Colors.colorize(text, Colors.BRIGHT_CYAN)

    @staticmethod
    def header(text: str) -> str:
        """Magenta bold text for headers."""
        return Colors.colorize(text, Colors.BRIGHT_MAGENTA, Colors.BOLD)

    @staticmethod
    def dim(text: str) -> str:
        """Dimmed text for low-priority information."""
        return Colors.colorize(text, Colors.WHITE, Colors.DIM)

    @staticmethod
    def highlight(text: str) -> str:
        """Yellow background for highlights."""
        return Colors.colorize(text, Colors.BLACK, Colors.BG_YELLOW + Colors.BOLD)

    @staticmethod
    def critical(text: str) -> str:
        """White text on red background for critical messages."""
        return Colors.colorize(text, Colors.BRIGHT_WHITE, Colors.BG_RED + Colors.BOLD)

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('logs/realtime_orderbook_monitor.log')
    ]
)
logger = logging.getLogger(__name__)

class RealtimeOrderbookMonitor:
    """Real-time orderbook data monitor for cryptocurrency futures."""

    def __init__(self, symbols: List[str], output_dir: str = "data/realtime_orderbooks",
                 duration_hours: Optional[int] = None, verbose: bool = False,
                 depth: int = 20, update_interval: int = 1000):
        """
        Initialize the orderbook monitor.

        Args:
            symbols: List of cryptocurrency symbols to monitor (e.g., ['BTC', 'ETH'])
            output_dir: Directory to save orderbook data
            duration_hours: Optional monitoring duration in hours
            verbose: Enable verbose logging
            depth: Orderbook depth to capture (default: 20 levels)
            update_interval: Update interval in milliseconds (default: 1000ms)
        """
        self.symbols = [s.upper() for s in symbols]
        self.output_dir = Path(output_dir)
        self.duration_hours = duration_hours
        self.verbose = verbose
        self.depth = depth
        self.update_interval = update_interval

        # Create output directory
        self.output_dir.mkdir(parents=True, exist_ok=True)

        # Initialize data structures
        self.orderbook_data = {symbol: [] for symbol in self.symbols}
        self.stats = {
            'start_time': datetime.now(),
            'total_updates': 0,
            'symbol_stats': {symbol: {'updates': 0, 'last_update': None} for symbol in self.symbols},
            'last_update': datetime.now()
        }

        # Control flags
        self.running = True
        self.connected = False

        # WebSocket URLs - use depth streams for orderbook data
        self.ws_base_url = "wss://fstream.binance.com/ws/"

        # Setup signal handlers for graceful shutdown
        signal.signal(signal.SIGINT, self.signal_handler)
        signal.signal(signal.SIGTERM, self.signal_handler)

        logger.info(Colors.success(f"Initialized orderbook monitor for symbols: {self.symbols}"))

    def signal_handler(self, signum, frame):
        """Handle shutdown signals gracefully."""
        logger.info(f"Received signal {signum}, shutting down gracefully...")
        self.running = False

    async def connect_websocket(self):
        """Connect to Binance Futures WebSocket for orderbook streams."""
        # Create streams for all symbols with specified depth
        streams = [f"{symbol.lower()}usdt@depth{self.depth}@100ms" for symbol in self.symbols]
        ws_url = self.ws_base_url + "/".join(streams)

        logger.info(f"Connecting to WebSocket: {ws_url}")

        try:
            async with websockets.connect(ws_url) as ws:
                self.connected = True
                logger.info(Colors.success("‚úÖ Connected to Binance Futures WebSocket"))

                # Send subscription message for faster updates if needed
                # await ws.send(json.dumps({
                #     "method": "SUBSCRIBE",
                #     "params": streams,
                #     "id": 1
                # }))

                while self.running:
                    try:
                        message = await asyncio.wait_for(ws.recv(), timeout=10.0)
                        await self.process_message(message)
                    except asyncio.TimeoutError:
                        logger.warning("WebSocket timeout - checking connection...")
                        continue
                    except Exception as e:
                        logger.error(f"Error receiving message: {e}")
                        break

        except Exception as e:
            logger.error(f"WebSocket connection error: {e}")
            self.connected = False
        finally:
            self.connected = False
            logger.info("WebSocket connection closed")

    async def process_message(self, message: str):
        """Process incoming WebSocket message."""
        try:
            data = json.loads(message)

            # Handle orderbook depth updates
            if 'stream' in data and 'data' in data:
                stream_data = data['data']
                stream_name = data.get('stream', 'unknown')

                # Extract symbol from stream name (e.g., 'btcusdt@depth20@100ms' -> 'BTC')
                symbol = stream_name.split('@')[0].upper()

                if symbol in self.symbols:
                    await self.process_orderbook_update(symbol, stream_data)

            elif data.get('event') == 'depthUpdate':
                # Alternative format handling
                symbol = data.get('symbol', '').replace('USDT', '')
                if symbol in self.symbols:
                    await self.process_orderbook_update(symbol, data)

        except json.JSONDecodeError as e:
            logger.warning(f"Failed to parse WebSocket message: {e}")
        except Exception as e:
            logger.error(f"Error processing message: {e}")

    async def process_orderbook_update(self, symbol: str, orderbook_data: Dict):
        """Process an orderbook update and store the data."""
        try:
            # Extract orderbook data
            timestamp = datetime.fromtimestamp(orderbook_data['E'] / 1000)  # Event time
            last_update_id = orderbook_data['u']  # Last update ID

            # Process bids and asks
            bids = orderbook_data.get('b', [])  # Bid levels
            asks = orderbook_data.get('a', [])  # Ask levels

            # Create orderbook snapshot
            orderbook_snapshot = {
                'timestamp': timestamp,
                'symbol': symbol,
                'last_update_id': last_update_id,
                'bids': bids[:self.depth],  # Limit to specified depth
                'asks': asks[:self.depth],  # Limit to specified depth
                'event_time': orderbook_data['E'],
                'transaction_time': orderbook_data.get('T', orderbook_data['E'])
            }

            # Calculate basic metrics
            if bids and asks:
                best_bid = float(bids[0][0]) if bids[0] else 0
                best_ask = float(asks[0][0]) if asks[0] else 0
                spread = best_ask - best_bid if best_bid and best_ask else 0
                mid_price = (best_bid + best_ask) / 2 if best_bid and best_ask else 0

                orderbook_snapshot.update({
                    'best_bid': best_bid,
                    'best_ask': best_ask,
                    'spread': spread,
                    'mid_price': mid_price,
                    'spread_pct': (spread / mid_price * 100) if mid_price else 0
                })

                # Calculate depth metrics
                bid_volume = sum(float(bid[1]) for bid in bids[:10])  # Top 10 bids
                ask_volume = sum(float(ask[1]) for ask in asks[:10])  # Top 10 asks

                orderbook_snapshot.update({
                    'bid_volume_top10': bid_volume,
                    'ask_volume_top10': ask_volume,
                    'total_volume_top10': bid_volume + ask_volume
                })

            # Store the orderbook data
            self.orderbook_data[symbol].append(orderbook_snapshot)

            # Update statistics
            self.stats['total_updates'] += 1
            self.stats['symbol_stats'][symbol]['updates'] += 1
            self.stats['symbol_stats'][symbol]['last_update'] = timestamp
            self.stats['last_update'] = datetime.now()

            # Log significant updates
            if self.verbose:
                logger.info(f"üìä {Colors.data(symbol)} orderbook updated | Best Bid: {Colors.data(f'${best_bid:.2f}') if best_bid else 'N/A'} | Best Ask: {Colors.data(f'${best_ask:.2f}') if best_ask else 'N/A'} | Spread: {Colors.data(f'${spread:.2f}') if spread else 'N/A'}")

            # Periodic save to file (every 100 updates or 5 minutes)
            total_updates = sum(len(data) for data in self.orderbook_data.values())
            if total_updates % 100 == 0:
                await self.save_data_to_files()

        except Exception as e:
            logger.error(f"Error processing orderbook update for {symbol}: {e}")

    def display_stats_loop(self):
        """Display real-time statistics every 30 seconds with colored output."""
        while self.running:
            time.sleep(30)  # Update every 30 seconds

            if not self.orderbook_data:
                continue

            # Clear screen and show stats with colors
            print("\n" + Colors.header("="*70))
            print(Colors.header("üìä REAL-TIME ORDERBOOK MONITOR"))
            print(Colors.header("="*70))
            print(f"‚è∞ Running since: {Colors.data(self.stats['start_time'].strftime('%Y-%m-%d %H:%M:%S'))}")
            connection_status = Colors.success("‚úÖ Connected") if self.connected else Colors.error("‚ùå Disconnected")
            print(f"üîó Connection: {connection_status}")
            total_updates_str = f"{self.stats['total_updates']:,}"
            print(f"üìä Total Orderbook Updates: {Colors.highlight(total_updates_str)}")

            if self.duration_hours:
                elapsed = datetime.now() - self.stats['start_time']
                remaining = timedelta(hours=self.duration_hours) - elapsed
                remaining_str = str(remaining).split('.')[0]
                if remaining.total_seconds() < 3600:  # Less than 1 hour remaining
                    remaining_display = Colors.warning(remaining_str)
                else:
                    remaining_display = Colors.data(remaining_str)
                print(f"‚è≥ Time remaining: {remaining_display}")

            print(f"\n{Colors.header('üìà Per-Symbol Statistics:')}")
            print(Colors.dim("-" * 50))
            for symbol in self.symbols:
                stats = self.stats['symbol_stats'][symbol]
                last_update = stats['last_update']

                # Calculate time since last update
                time_since_update = "Never"
                if last_update:
                    time_diff = datetime.now() - last_update
                    if time_diff.seconds < 60:
                        time_since_update = f"{time_diff.seconds}s ago"
                    elif time_diff.seconds < 3600:
                        time_since_update = f"{time_diff.seconds // 60}m ago"
                    else:
                        time_since_update = f"{time_diff.seconds // 3600}h ago"

                # Color coding based on activity
                if stats['updates'] > 100:
                    count_display = Colors.success(f"{stats['updates']:6d}")
                elif stats['updates'] > 10:
                    count_display = Colors.data(f"{stats['updates']:6d}")
                else:
                    count_display = Colors.warning(f"{stats['updates']:6d}")

                time_display = Colors.success(time_since_update) if last_update and (datetime.now() - last_update).seconds < 10 else Colors.warning(time_since_update)

                print(f"  {Colors.info(symbol):6} {count_display} Last update: {time_display}")

            print(f"\nüìÅ Data saved to: {Colors.data(str(self.output_dir))}")
            print(Colors.info("üí° Press Ctrl+C to stop monitoring"))
            print(Colors.header("="*70))

    async def save_data_to_files(self):
        """Save orderbook data to CSV files and create compressed backups."""
        try:
            for symbol in self.symbols:
                if not self.orderbook_data[symbol]:
                    continue

                # Create symbol directory
                symbol_dir = self.output_dir / symbol.lower()
                symbol_dir.mkdir(exist_ok=True)

                # Save to CSV
                csv_file = symbol_dir / f"{symbol.lower()}_orderbook_realtime.csv"

                # Convert to DataFrame
                df_data = []
                for entry in self.orderbook_data[symbol]:
                    row = {
                        'timestamp': entry['timestamp'],
                        'symbol': entry['symbol'],
                        'last_update_id': entry['last_update_id'],
                        'best_bid': entry.get('best_bid', 0),
                        'best_ask': entry.get('best_ask', 0),
                        'spread': entry.get('spread', 0),
                        'mid_price': entry.get('mid_price', 0),
                        'spread_pct': entry.get('spread_pct', 0),
                        'bid_volume_top10': entry.get('bid_volume_top10', 0),
                        'ask_volume_top10': entry.get('ask_volume_top10', 0),
                        'total_volume_top10': entry.get('total_volume_top10', 0),
                        'event_time': entry['event_time'],
                        'transaction_time': entry['transaction_time']
                    }
                    df_data.append(row)

                if df_data:
                    df = pd.DataFrame(df_data)
                    df.to_csv(csv_file, index=False)
                    logger.info(f"üíæ Saved orderbook data: {csv_file} ({len(df_data)} updates)")

                    # Create compressed backup every hour
                    now = datetime.now()
                    if now.minute == 0:  # Top of the hour
                        compressed_file = symbol_dir / f"{symbol.lower()}_orderbook_{now.strftime('%Y%m%d_%H')}.csv.gz"
                        with gzip.open(compressed_file, 'wt') as f:
                            df.to_csv(f, index=False)
                        logger.info(f"üì¶ Saved compressed orderbook data: {compressed_file}")

        except Exception as e:
            logger.error(f"Error saving orderbook data: {e}")

    def print_final_summary(self):
        """Print final summary when monitoring stops with colored output."""
        print("\n" + Colors.header("="*80))
        print(Colors.success("üèÅ ORDERBOOK MONITORING SESSION COMPLETE"))
        print(Colors.header("="*80))

        runtime = datetime.now() - self.stats['start_time']
        runtime_str = str(runtime).split('.')[0]
        print(f"‚è∞ Session Duration: {Colors.data(runtime_str)}")

        total_updates = self.stats['total_updates']
        print(f"üìä Total Orderbook Updates: {Colors.highlight(f'{total_updates:,}')}")

        if total_updates > 0:
            avg_per_minute = total_updates / (runtime.total_seconds() / 60)
            print(f"üìà Average Updates/Minute: {Colors.data(f'{avg_per_minute:.1f}')}")

        print(f"\n{Colors.header('üìà Final Symbol Statistics:')}")
        print(Colors.dim("-" * 50))
        for symbol in self.symbols:
            stats = self.stats['symbol_stats'][symbol]
            if stats['updates'] > 0:
                last_update = stats['last_update']
                time_display = last_update.strftime('%H:%M:%S') if last_update else 'Never'

                count_display = Colors.success(f"{stats['updates']:6d}") if stats['updates'] > 50 else Colors.data(f"{stats['updates']:6d}")
                print(f"  {Colors.info(symbol):6} {count_display} Last update: {Colors.data(time_display)}")
            else:
                print(f"  {Colors.warning(symbol):6} {Colors.dim('No updates received')}")

        print(f"\nüìÅ Data Location: {Colors.data(str(self.output_dir))}")
        files_found = 0
        for symbol in self.symbols:
            csv_file = self.output_dir / symbol.lower() / f"{symbol.lower()}_orderbook_realtime.csv"
            if csv_file.exists():
                size_mb = csv_file.stat().st_size / (1024 * 1024)
                size_display = Colors.success(f"{size_mb:.1f} MB") if size_mb > 1 else Colors.data(f"{size_mb:.1f} MB")
                print(f"   {Colors.info(symbol):6}: {size_display}")
                files_found += 1

        if files_found == 0:
            print(Colors.warning("   No data files were created"))

        print(f"\n{Colors.success('üéØ Next Steps:')}")
        print("  ‚Ä¢ Analyze orderbook depth and liquidity patterns")
        print("  ‚Ä¢ Study bid-ask spread dynamics")
        print("  ‚Ä¢ Monitor market depth changes during volatility")
        print("  ‚Ä¢ Use for order flow analysis and market making strategies")
        print(Colors.header("="*80))

    async def run_monitor(self):
        """Run the orderbook monitor."""
        try:
            # Start the display thread
            display_thread = threading.Thread(target=self.display_stats_loop, daemon=True)
            display_thread.start()

            while self.running:
                await self.connect_websocket()

                if self.running:  # Only reconnect if not manually stopped
                    logger.info("üîÑ Reconnecting in 5 seconds...")
                    await asyncio.sleep(5)

        except Exception as e:
            logger.error(f"Monitor error: {e}")
        finally:
            # Final save of all data
            await self.save_data_to_files()
            self.print_final_summary()


def main():
    """Main entry point with command line argument parsing."""
    parser = argparse.ArgumentParser(description='Real-Time Cryptocurrency Orderbook Monitor')
    parser.add_argument('--symbols', nargs='+', help='Cryptocurrency symbols to monitor (e.g., BTC ETH)')
    parser.add_argument('--all', action='store_true', help='Monitor all major cryptocurrencies')
    parser.add_argument('--quality-data', action='store_true',
                       help='Monitor symbols from quality data categories (full_history, good_coverage, established)')
    parser.add_argument('--duration', type=int, help='Monitoring duration in hours (default: indefinite)')
    parser.add_argument('--output', default='data/realtime_orderbooks',
                       help='Output directory for orderbook data')
    parser.add_argument('--verbose', action='store_true',
                       help='Show verbose logging including all WebSocket messages')
    parser.add_argument('--depth', type=int, default=20,
                       help='Orderbook depth to capture (default: 20)')
    parser.add_argument('--update-interval', type=int, default=100,
                       help='Update interval in milliseconds (default: 100ms)')

    args = parser.parse_args()

    # Determine symbols to monitor
    if args.all:
        # Major cryptocurrencies available on Binance Futures
        symbols = ['BTC', 'ETH', 'BNB', 'ADA', 'XRP', 'SOL', 'DOT', 'DOGE', 'AVAX', 'LTC']
    elif args.quality_data:
        # Symbols from quality data categories (full_history, good_coverage, established)
        symbols = ['AAVE', 'ADA', 'AVAX', 'BCH', 'BNB', 'BTC', 'DOGE', 'DOT', 'ETC', 'ETH',
                  'FIL', 'HBAR', 'LINK', 'LTC', 'SHIB', 'SOL', 'THETA', 'TRX', 'UNI',
                  'USDC', 'XLM', 'XMR', 'XRP', 'ZEC']
    elif args.symbols:
        symbols = args.symbols
    else:
        print("‚ùå Please specify --symbols, --all, or --quality-data")
        print("\nExamples:")
        print("  python realtime_orderbook_monitor.py --symbols BTC ETH")
        print("  python realtime_orderbook_monitor.py --all")
        print("  python realtime_orderbook_monitor.py --quality-data")
        print("  python realtime_orderbook_monitor.py --symbols BTC --depth 50")
        sys.exit(1)

    # Validate symbols (basic check for common symbols)
    valid_symbols = ['AAVE', 'ADA', 'ALGO', 'AVAX', 'BCH', 'BNB', 'BTC', 'DOGE', 'DOT', 'ETC', 'ETH',
                    'FIL', 'HBAR', 'ICP', 'LINK', 'LTC', 'SHIB', 'SOL', 'THETA', 'TRX', 'UNI',
                    'USDC', 'VET', 'XLM', 'XMR', 'XRP', 'ZEC']

    invalid_symbols = [s for s in symbols if s.upper() not in valid_symbols]
    if invalid_symbols:
        print(f"‚ö†Ô∏è  Warning: These symbols may not be available on Binance Futures: {invalid_symbols}")

    # Create and run monitor
    monitor = RealtimeOrderbookMonitor(
        symbols=symbols,
        output_dir=args.output,
        duration_hours=args.duration,
        verbose=args.verbose,
        depth=args.depth,
        update_interval=args.update_interval
    )

    print(Colors.success("üöÄ Starting Real-Time Orderbook Monitor"))
    print(f"üìä Monitoring: {Colors.data(', '.join(symbols))}")
    print(f"üìÅ Output: {Colors.data(args.output)}")
    print(f"üìè Depth: {Colors.data(str(args.depth))} levels")
    if args.duration:
        print(f"‚è∞ Duration: {Colors.warning(f'{args.duration} hours')}")
    else:
        print(f"‚è∞ Duration: {Colors.info('Indefinite (Ctrl+C to stop)')}")
    print(Colors.header("="*60))

    # Run the async monitor
    try:
        asyncio.run(monitor.run_monitor())
    except KeyboardInterrupt:
        print(f"\n{Colors.warning('‚ö†Ô∏è  Monitoring stopped by user')}")
    except Exception as e:
        print(f"\n{Colors.error('‚ùå Error:')} {Colors.data(str(e))}")
        sys.exit(1)


if __name__ == "__main__":
    main()
